<head>
    <script src="gl-matrix-min.js"></script>
    <script>
        function main() {
            canvas = document.querySelector("#glCanvas");
            canvas.addEventListener("mousedown", doMouseDown, false);
            // Initialize the GL context
            const gl = canvas.getContext("webgl");
        
            // Only continue if WebGL is available and working
            if (gl === null) {
                alert("Unable to initialize WebGL. Your browser or machine may not support it.");
                return;
            }
        
            // Vertex shader program
            const vsSource = `
                attribute vec4 aVertexPosition;
                attribute vec3 aVertexNormal; // ** LIGHTING **
                attribute vec4 aVertexColor;

                uniform mat4 uNormalMatrix; // ** LIGHTING **
                uniform mat4 uModelViewMatrix;
                uniform mat4 uProjectionMatrix;

                varying lowp vec4 vColor;
                varying highp vec3 vLighting; // ** LIGHTING **

                void main(void) {
                    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                    vColor = aVertexColor;

                    // Apply lighting effect // ** LIGHTING **

                    highp vec3 ambientLight = vec3(0.3, 0.3, 0.3);
                    highp vec3 directionalLightColor = vec3(1, 1, 1);
                    highp vec3 directionalVector = normalize(vec3(0.85, 0.8, 0.75));

                    highp vec4 transformedNormal = uNormalMatrix * vec4(aVertexNormal, 1.0);

                    highp float directional = max(dot(transformedNormal.xyz, directionalVector), 0.0);
                    vLighting = ambientLight + (directionalLightColor * directional);
                }
            `;

            // Fragment shader program 
            const fsSource = `
                varying lowp vec4 vColor;
                varying highp vec3 vLighting; // ** LIGHTING **

                void main(void) {
                    gl_FragColor = vec4(vColor.rgb * vLighting, vColor.a); // ** LIGHTING **
                }
            `;

            // Initialize a shader program; this is where all the lighting
            // for the vertices and so forth is established.
            const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

            // Collect all the info needed to use the shader program.
            // Look up which attribute our shader program is using
            // for aVertexPosition and look up uniform locations.
            const programInfo = {
                program: shaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                    vertexNormal: gl.getAttribLocation(shaderProgram, 'aVertexNormal'), // ** LIGHTING **
                    vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor'),
                },
                uniformLocations: {
                    projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                    modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                    normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'), // ** LIGHTING **
                }
            };

            // coordinate to draw box
            const positionsBox = [
                // Front face
                -1.0, -1.0,  1.0, // 0
                1.0, -1.0,  1.0, // 1
                1.0,  1.0,  1.0, // 2
                -1.0,  1.0,  1.0, // 3

                // Back face
                -1.0, -1.0, -1.0, // 4
                -1.0,  1.0, -1.0, // 5
                1.0,  1.0, -1.0, // 6
                1.0, -1.0, -1.0, // 7

                // Top face
                -1.0,  1.0, -1.0, // 8
                -1.0,  1.0,  1.0, // 9
                1.0,  1.0,  1.0, // 10
                1.0,  1.0, -1.0, // 11

                // Bottom face
                -1.0, -1.0, -1.0, // 12
                1.0, -1.0, -1.0, // 13
                1.0, -1.0,  1.0, // 14
                -1.0, -1.0,  1.0, // 15

                // Right face
                1.0, -1.0, -1.0, // 16
                1.0,  1.0, -1.0, // 17
                1.0,  1.0,  1.0, // 18
                1.0, -1.0,  1.0, // 19

                // Left face
                -1.0, -1.0, -1.0, // 20
                -1.0, -1.0,  1.0, // 21
                -1.0,  1.0,  1.0, // 22
                -1.0,  1.0, -1.0, // 23
            ];

            gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque
            gl.clearDepth(1.0);                 // Clear everything
            gl.enable(gl.DEPTH_TEST);           // Enable depth testing
            gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

            const fieldOfView = 45 * Math.PI / 180;   // in radians
            const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
            const zNear = 0.1;
            const zFar = 100.0;
            const projectionMatrix = mat4.create();

            // Put perspective matrix into "cameraMatrix" variable
            var cameraMatrix = mat4.perspective(projectionMatrix,
                                fieldOfView,
                                aspect,
                                zNear,
                                zFar);

            //Parent:
            //kerusi

            //Child:
            //sandar
            //seat
            //tangan
            //batang kerusi

            //GChild:
            //roda
        

            // Translate camera using sliders                    
            cameraMatrix = mat4.translate(cameraMatrix,cameraMatrix,[-cMoveX, -cMoveY, -cMoveZ]);   
            // Roatate camera a bit for nice effect
            let cameraRotateDefault = 30 * 0.0174533;
            cameraMatrix = mat4.rotate(cameraMatrix,cameraMatrix,cameraRotateDefault,[0,1,0]);
                                
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // Clear the canvas before we start drawing on it.

            // modelViewMatrix declaration (make the drawing after this centered to 0,0,0 origin coordinate)
            let modelViewMatrix = mat4.create(); 

            // Declare colorsBuffer & initialize it
            var colorsBuffer = initBuffers(gl,positionsBox,whiteColors);

            // Translate PARENT object 
            mat4.translate(modelViewMatrix,modelViewMatrix,[pMoveX,pMoveY,pMoveZ]);
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ);
            
            // draw kerusi(PARENT)
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.4,0.8,0.4]); 
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,0]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // ********************************************
            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create(); 
            
            // replace colorsBuffer with new color (the "blueColors")
            colorsBuffer = initBuffers(gl,positionsBox,blueColors);

            // Translate Parent object on slider
            mat4.translate(modelViewMatrix,modelViewMatrix,[pMoveX,pMoveY,pMoveZ]);  
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ);

            // Rotate on button clicked
            mat4.rotateY(modelViewMatrix,modelViewMatrix,transformChildY);

            //DRAW CHILD

             // draw seat 
            mat4.scale(modelViewMatrix,modelViewMatrix,[2,0.2,2]);  
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,4,0]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
             
            // replace colorsBuffer with new color (the "orangeColors")
            colorsBuffer = initBuffers(gl,positionsBox,blueColors);
            
            //draw tempat sandar
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.1,8,1]);  
            mat4.translate(modelViewMatrix,modelViewMatrix,[8,1,0]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            //draw tempat tangan atas kanan
            mat4.scale(modelViewMatrix,modelViewMatrix,[8,0.1,0.1]);  
            mat4.translate(modelViewMatrix,modelViewMatrix,[-1,-0.2,8]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            //draw tempat tangan bawah kanan
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.1,5,1]);  
            mat4.translate(modelViewMatrix,modelViewMatrix,[-8,-1,0]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            //draw tempat tangan atas kiri
            mat4.scale(modelViewMatrix,modelViewMatrix,[10,0.2,0.9]);  
            mat4.translate(modelViewMatrix,modelViewMatrix,[0.85,5,-18]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            //draw tempat tangan 4
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.1,5,1]);  
            mat4.translate(modelViewMatrix,modelViewMatrix,[-8,-1,0]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // ********************************************
            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create(); 
            
            // replace colorsBuffer with new color (the "blueColors")
            colorsBuffer = initBuffers(gl,positionsBox,blueColors);

            // Translate Parent object on slider
            mat4.translate(modelViewMatrix,modelViewMatrix,[pMoveX,pMoveY,pMoveZ]);  
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ);
            
            // Rotate on button clicked
            mat4.rotateY(modelViewMatrix,modelViewMatrix,transformChildY);

             //draw kotak CHILD
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.6,0.4,0.6]); 
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,-2.5,0]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
            
            // ********************************************
            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create(); 
            
            // replace colorsBuffer with new color (the "whiteColors")
            colorsBuffer = initBuffers(gl,positionsBox,blueColors);

            // Translate Parent object on slider
            mat4.translate(modelViewMatrix,modelViewMatrix,[pMoveX,pMoveY,pMoveZ]);  
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ);


             // Rotate on button clicked
            mat4.rotateY(modelViewMatrix,modelViewMatrix,transformChildY);

            // DRAW CHILD ( kaki kerusi )

             // draw kaki kerusi 1
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.4,0.2,1]); 
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,-5,1.5]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // draw kaki kerusi 2
            mat4.scale(modelViewMatrix,modelViewMatrix,[2.2,1,0.4]); 
            mat4.translate(modelViewMatrix,modelViewMatrix,[-1.5,0,-3.8]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
            
             // draw kaki kerusi 3
             mat4.scale(modelViewMatrix,modelViewMatrix,[0.4,1,2.2]); 
            mat4.translate(modelViewMatrix,modelViewMatrix,[3.8,0,-1.6]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
            
            // draw kaki kerusi 4
            mat4.scale(modelViewMatrix,modelViewMatrix,[2.4,1,0.5]); 
            mat4.translate(modelViewMatrix,modelViewMatrix,[1.5,0,3.3]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
            
            // ********************************************
            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create(); 
            
            // replace colorsBuffer with new color (the "orangeColors")
            colorsBuffer = initBuffers(gl,positionsBox,orangeColors);

            // Translate Parent object on slider
            mat4.translate(modelViewMatrix,modelViewMatrix,[pMoveX,pMoveY,pMoveZ]);  
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ);

                   // Rotate on button clicked
                   mat4.rotateY(modelViewMatrix,modelViewMatrix,transformChildY);

            //DRAW GRANDCHILD (tayar)

 
             //draw tayar 1 (grandchild)
             mat4.scale(modelViewMatrix,modelViewMatrix,[0.4,0.2,0.4]); 
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,-7,6]);
            // Rotate tayar 1 (grandchild) on button clicked
            mat4.rotateY(modelViewMatrix,modelViewMatrix,transformGrandZ); 
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

          // ********************************************
            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create(); 
            
            // replace colorsBuffer with new color (the "orangeColors")
            colorsBuffer = initBuffers(gl,positionsBox,orangeColors);

            // Translate Parent object on slider
            mat4.translate(modelViewMatrix,modelViewMatrix,[pMoveX,pMoveY,pMoveZ]);  
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ);

            // Rotate on button clicked
            mat4.rotateY(modelViewMatrix,modelViewMatrix,transformChildY);

            //draw tayar 2 (grandchild)
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.4,0.2,0.4]); 
            mat4.translate(modelViewMatrix,modelViewMatrix,[-5.3,-7,0]);
            // Rotate tayar 1 (grandchild) on button clicked
            mat4.rotateY(modelViewMatrix,modelViewMatrix,transformGrandZ);    
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
      

            // ********************************************
            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create(); 
            
            // replace colorsBuffer with new color (the "orangeColors")
            colorsBuffer = initBuffers(gl,positionsBox,orangeColors);

            // Translate Parent object on slider
            mat4.translate(modelViewMatrix,modelViewMatrix,[pMoveX,pMoveY,pMoveZ]);  
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ);

            // Rotate on button clicked
            mat4.rotateY(modelViewMatrix,modelViewMatrix,transformChildY);

   
             //draw tayar 3 (grandchild)
             mat4.scale(modelViewMatrix,modelViewMatrix,[0.4,0.2,0.4]); 
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,-7,-5.3]);
             // Rotate tayar 1 (grandchild) on button clicked
            mat4.rotateY(modelViewMatrix,modelViewMatrix,transformGrandZ);           
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
            //  // Rotate fan blades (grandchild) on button clicked
            //  mat4.rotateZ(modelViewMatrix,modelViewMatrix,transformGrandZ);


            // ********************************************
            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create(); 
            
            // replace colorsBuffer with new color (the "orangeColors")
            colorsBuffer = initBuffers(gl,positionsBox,orangeColors);

            // Translate Parent object on slider
            mat4.translate(modelViewMatrix,modelViewMatrix,[pMoveX,pMoveY,pMoveZ]);  
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ);

            // Rotate on button clicked
            mat4.rotateY(modelViewMatrix,modelViewMatrix,transformChildY);

   
            //draw tayar 4 (grandchild)
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.4,0.2,0.4]); 
            mat4.translate(modelViewMatrix,modelViewMatrix,[5.3,-7,0]);
            // Rotate tayar 1 (grandchild) on button clicked
            mat4.rotateY(modelViewMatrix,modelViewMatrix,transformGrandZ);           
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);


             // ********************************************
            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create(); 

            // Translate Parent object on slider
            mat4.translate(modelViewMatrix,modelViewMatrix,[pMoveX,pMoveY,pMoveZ]);  
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);   
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);  
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ);  

            // replace colorsBuffer with new color (the "orangeColors2") with 1.0 alpha
            var orangeColors2 = [ 
                [0.960, 0.784, 0.658, 1.0],    
                [0.960, 0.784, 0.658, 1.0],   
                [0.992, 0.741, 0.568, 1.0],   
                [0.992, 0.741, 0.568, 1.0],  
                [0.843, 0.556, 0.356, 1.0],
                [0.843, 0.556, 0.356, 1.0],
            ];
            colorsBuffer = initBuffers(gl,positionsBox,orangeColors2);



            
           

        }
        
        // Array for variance of redColors
        var redColors = [ 
            [0.839,  0.180,  0.180, 1.0],    
            [0.839,  0.180,  0.180, 1.0],    
            [0.874,  0.066,  0.066, 1.0],    
            [0.874,  0.066,  0.066, 1.0],      
            [0.941,  0.098,  0.098, 1.0],   
            [0.941,  0.098,  0.098, 1.0],   
        ];

        // Array for variance of whiteColors
        var whiteColors = [ 
            [0.992, 0.929, 0.929, 1.0],    
            [0.992, 0.929, 0.929, 1.0],   
            [1, 1, 1, 1.0],   
            [1, 1, 1, 1.0],   
            [0.972, 0.949, 0.949, 1.0],   
            [0.972, 0.949, 0.949, 1.0],   
        ];

        // Array for variance of orangeColors
        var orangeColors = [ 
             [0.921, 0.447, 0.117, 1.0],    
            [0.921, 0.447, 0.117, 1.0],   
            [1, 0.423, 0.019, 1.0],   
            [1, 0.423, 0.019, 1.0],  
            [0.937, 0.541, 0.262, 1.0],
            [0.937, 0.541, 0.262, 1.0],
        ];

        // Array for variance of blueColors
        var blueColors = [ 
            [0, 0, 1.200, 1.0],    
            [0, 0, 1.200, 1.0],   
            [0, 0.5, 0.880, 1.0],   
            [0, 0.5, 0.880, 1.0],   
            [0, 0.4, 0.770, 1.0],   
            [0, 0.4, 0.770, 1.0], 
            [0.266,  0.972,  0.890, 1.0],   
        ];


        var rotateX = 0, rotateY = 0, rotateZ = 0;

        // Mouse drag to rotateX & rotateY
        // *******************************
        var prevx, prevy, canvas;
        var dragging = false;

        function doMouseDown(evt) {
            if (dragging)
                return;
            dragging = true;
            document.addEventListener("mousemove", doMouseDrag, false);
            document.addEventListener("mouseup", doMouseUp, false);
            var box = canvas.getBoundingClientRect();
            prevx = window.pageXOffset + evt.clientX - box.left;
            prevy = window.pageYOffset + evt.clientY - box.top;
        }

        function doMouseDrag(evt) {
            if (!dragging)
                return;
            var box = canvas.getBoundingClientRect();
            var x = window.pageXOffset + evt.clientX - box.left;
            var y = window.pageYOffset + evt.clientY - box.top;
            let diffy = (prevx - x) * 0.01;
            let diffx = (prevy - y) * 0.01;
            prevx = x;
            prevy = y;
            rotateX = rotateX - diffx;
            rotateY = rotateY - diffy;
            main();
        }
        
        function doMouseUp(evt) {
            if (dragging) {
                document.removeEventListener("mousemove", doMouseDrag, false);
                document.removeEventListener("mouseup", doMouseUp, false);
                dragging = false;
            }
        }
        
        function resetRotation() {
            rotateX = 0, rotateY = 0, rotateZ = 0;
            main();
        }
        // *******************************
        
        window.onload = main;

        // ########################################### //
        // initBuffers 
        //
        // Initialize the buffers we'll need. For this demo, we just
        // have one object -- a simple three-dimensional cube.
        //
        function initBuffers(gl,positions,faceColors) {

            // Create a buffer for the square's positions.
            const positionBuffer = gl.createBuffer();

            // Select the positionBuffer as the one to apply buffer
            // operations to from here out.
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

            // Now pass the list of positions into WebGL to build the
            // shape. We do this by creating a Float32Array from the
            // JavaScript array, then use it to fill the current buffer.
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            // ** LIGHTING **
            // Set up the normals for the vertices, so that we can compute lighting.
            const normalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);

            // ** LIGHTING **
            const vertexNormals = [
                // Front
                0.0,  0.0,  1.0,
                0.0,  0.0,  1.0,
                0.0,  0.0,  1.0,
                0.0,  0.0,  1.0,

                // Back
                0.0,  0.0, -1.0,
                0.0,  0.0, -1.0,
                0.0,  0.0, -1.0,
                0.0,  0.0, -1.0,

                // Top
                0.0,  1.0,  0.0,
                0.0,  1.0,  0.0,
                0.0,  1.0,  0.0,
                0.0,  1.0,  0.0,

                // Bottom
                0.0, -1.0,  0.0,
                0.0, -1.0,  0.0,
                0.0, -1.0,  0.0,
                0.0, -1.0,  0.0,

                // Right
                1.0,  0.0,  0.0,
                1.0,  0.0,  0.0,
                1.0,  0.0,  0.0,
                1.0,  0.0,  0.0,

                // Left
                -1.0,  0.0,  0.0,
                -1.0,  0.0,  0.0,
                -1.0,  0.0,  0.0,
                -1.0,  0.0,  0.0
            ];

            // ** LIGHTING **
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW);

            // Color buffer                
            var colors = [];

            for (var j = 0; j < faceColors.length; ++j) {
                const c = faceColors[j];
                colors = colors.concat(c, c, c, c);
            }

            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

            // Build the element array buffer; this specifies the indices
            // into the vertex arrays for each face's vertices.
            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

            // This array defines each face as two triangles, using the
            // indices into the vertex array to specify each triangle's
            // position.
            const indices = [
                0,  1,  2,      0,  2,  3,    // front
                4,  5,  6,      4,  6,  7,    // back
                8,  9,  10,     8,  10, 11,   // top
                12, 13, 14,     12, 14, 15,   // bottom
                16, 17, 18,     16, 18, 19,   // right
                20, 21, 22,     20, 22, 23,   // left
            ];

            // Now send the element array to GL

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            return {
                position: positionBuffer,
                normal: normalBuffer, // ** LIGHTING **
                color: colorBuffer,
                indices: indexBuffer,
            };
        }

        // ########################################### //
        // Draw the scene.
        //
        function drawScene(gl, programInfo, buffers, modelViewMatrix, projectionMatrix) {
            // Tell WebGL how to pull out the positions from the position
            // buffer into the vertexPosition attribute.
            {
                const numComponents = 3; // (x,y,z)
                const type = gl.FLOAT;
                const normalize = false;
                const stride = 0;
                const offset = 0;
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexPosition,
                    numComponents,
                    type,
                    normalize,
                    stride,
                    offset);
                gl.enableVertexAttribArray(
                    programInfo.attribLocations.vertexPosition);
            }

            // Tell WebGL how to pull out the colors from the color buffer
            // into the vertexColor attribute.
            {
                const numComponents = 4; // (r,g,b,a)
                const type = gl.FLOAT;
                const normalize = false;
                const stride = 0;
                const offset = 0;
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexColor,
                    numComponents,
                    type,
                    normalize,
                    stride,
                    offset);
                gl.enableVertexAttribArray(
                    programInfo.attribLocations.vertexColor);
            }

            // ** LIGHTING ** Start ---
            var normalMatrix = mat4.create();
            mat4.invert(normalMatrix, modelViewMatrix);
            mat4.transpose(normalMatrix, normalMatrix);

            // Tell WebGL how to pull out the normals from
            // the normal buffer into the vertexNormal attribute.
            {
                const numComponents = 3; // (x, y, z)
                const type = gl.FLOAT;
                const normalize = false;
                const stride = 0;
                const offset = 0;
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexNormal,
                    numComponents,
                    type,
                    normalize,
                    stride,
                    offset);
                gl.enableVertexAttribArray(
                    programInfo.attribLocations.vertexNormal);
            }    
            // ** LIGHTING ** Finish ---

            // Tell WebGL which indices to use to index the vertices
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);

            // Tell WebGL to use our program when drawing
            gl.useProgram(programInfo.program);

            // Set the shader uniforms
            gl.uniformMatrix4fv(
                programInfo.uniformLocations.projectionMatrix,
                false,
                projectionMatrix);
            gl.uniformMatrix4fv(
                programInfo.uniformLocations.modelViewMatrix,
                false,
                modelViewMatrix);

            // ** LIGHTING **    
            gl.uniformMatrix4fv(
                programInfo.uniformLocations.normalMatrix,
                false,
                normalMatrix);
        }

        // ########################################### //
        // Initialize a shader program, so WebGL knows how to draw our data
        //
        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

            // Create the shader program
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            // If creating the shader program failed, alert
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }

            return shaderProgram;
        }

        // ########################################### //
        // creates a shader of the given type, uploads the source and
        // compiles it.
        //
        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);

            // Send the source to the shader object
            gl.shaderSource(shader, source);

            // Compile the shader program
            gl.compileShader(shader);

            // See if it compiled successfully
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        var transformChildY = 0, transformGrandZ = 0;
        var rotationSpeed = 1, transparencyValue = 1;
        var translateZ = 0, scaleY = 1, rotateObject = 0;

        // ########################################### //
        // PARENT & CAMERA MOVEMENT functions
        // ########################################### //

        var pMoveX = 0, pMoveY = 0, pMoveZ = 0;
        var cMoveX = 0, cMoveY = 1, cMoveZ = 10;

        function changeP1value() {
            pMoveX = document.getElementById("p1Value").value;
            document.getElementById("pMoveX").innerHTML = document.getElementById("p1Value").value;
            main(); 
        }

        function changeC1value() {
            cMoveX = document.getElementById("c1Value").value;
            document.getElementById("cMoveX").innerHTML = document.getElementById("c1Value").value;
            main(); 
        }

        function changeP2value() {
            pMoveY = document.getElementById("p2Value").value;
            document.getElementById("pMoveY").innerHTML = document.getElementById("p2Value").value;
            main(); 
        }

        function changeC2value() {
            cMoveY = document.getElementById("c2Value").value;
            document.getElementById("cMoveY").innerHTML = document.getElementById("c2Value").value;
            main(); 
        }

        function changeP3value() {
            pMoveZ = document.getElementById("p3Value").value;
            document.getElementById("pMoveZ").innerHTML = document.getElementById("p3Value").value;
            main(); 
        }

        function changeC3value() {
            cMoveZ = document.getElementById("c3Value").value;
            document.getElementById("cMoveZ").innerHTML = document.getElementById("c3Value").value;
            main(); 
        }


        // ########################################### //
        // TRANSFORMATION functions
        // ########################################### //

        var transformGrandBool = false, transformChildBool = false;
        var timerGrand = 0, timerChild = 0;

        // Transform Grandchild on/off switch
        function transformGrand() {
            if (transformGrandBool == false) { transformGrandBool = true; }
            else { transformGrandBool = false; }

            if (transformGrandBool == true) {
                timerGrand = setInterval(function(){ transformGrandLoop() }, 10);
                document.getElementById("grandBtn").value = "Stop (GRANDCHILD)";
            } else {
                clearInterval(timerGrand);
                document.getElementById("grandBtn").value = "GRANDCHILD";
            }
        }

        // Transform Grandchild by rotation on Z axis
        function transformGrandLoop() {
            transformGrandZ = transformGrandZ + (rotationSpeed * 0.0174533);
            // transformGrandX = transformGrandX + (rotationSpeed * 0.0174533);
            // transformGrandY = transformGrandY + (rotationSpeed * 0.0174533);
            main();
        }

        // Transform Child on/off switch
        function transformChild() {
            if (transformChildBool == false) { transformChildBool = true; }
            else { transformChildBool = false; }

            if (transformChildBool == true) {
                timerChild = setInterval(function(){ transformChildLoop() }, 10);
                document.getElementById("childBtn").value = "Stop (CHILD)";
            } else {
                clearInterval(timerChild);
                document.getElementById("childBtn").value = "CHILD";
            }
        }

        // Transform Child by rotation on Y axis
        var rotateClockwise = false;
        function transformChildLoop() {

            if (rotateClockwise == true) {
                transformChildY = transformChildY - (0.3 * 0.0174533);
                if (transformChildY < -1) {
                    rotateClockwise = false;
                } 
            } else {
                transformChildY = transformChildY + (0.3 * 0.0174533);
                if (transformChildY > 1) {
                    rotateClockwise = true;
                } 
            }
            main();
        }

        // Speed SLIDER functions
        function changeS1value() {
            // pass slider value into global variable "rotationSpeed" 
            rotationSpeed = document.getElementById("s1Value").value;
            // change "speedValue" label/span
            document.getElementById("speedValue").innerHTML = document.getElementById("s1Value").value;
            // calling the transformGrandLoop() function
            transformGrandLoop(); 
        }

        // ########################################### //
        // COLOR functions
        // ########################################### //

        var colorGrandBool = false, colorChildBool = false;

        // Change color for Grandchild object
        function colorGrand() {
            if (colorGrandBool == false) { colorGrandBool = true; }
            else { colorGrandBool = false; }

            if (colorGrandBool == true) {
                orangeColors = [ 
                    [0, 0.128, 0, transparencyValue],
                    [0, 0.128, 0, transparencyValue],
                    [0, 0.128, 0, transparencyValue],
                    [0, 0.128, 0, transparencyValue],
                    [0, 0.128, 0, transparencyValue],
                    [0, 0.128, 0, transparencyValue],
                    
                    
                    
                ];
                document.getElementById("grandBtn2").value = "Revert (GRANDCHILD)";
            } else {
                orangeColors = [ 
                    [0.921, 0.447, 0.117, transparencyValue],    
                    [0.921, 0.447, 0.117, transparencyValue],   
                    [1, 0.423, 0.019, transparencyValue],   
                    [1, 0.423, 0.019, transparencyValue],  
                    [0.937, 0.541, 0.262, transparencyValue],
                    [0.937, 0.541, 0.262, transparencyValue],   
                ];
                document.getElementById("grandBtn2").value = "GRANDCHILD";
            }

            main();
        }

        // Change color for Child object
        function colorChild() {
            if (colorChildBool == false) { colorChildBool = true; }
            else { colorChildBool = false; }

            if (colorChildBool == true) {
                blueColors = [ 
                    [255, 255, 0.5, 1.0],    
                    [255, 255, 0.5, 1.0],  
                    [255, 255, 0.5, 1.0],  
                    [255, 255, 0.5, 1.0],  
                    [255, 255, 0.5, 1.0],  
                    [255, 255, 0.5, 1.0],   
                ];
                document.getElementById("childBtn2").value = "Revert (CHILD)";
            } else {
                blueColors = [ 
                    [0, 0, 1.200, 1.0],    
                    [0, 0, 1.200, 1.0],   
                    [0, 0.5, 0.880, 1.0],   
                    [0, 0.5, 0.880, 1.0],   
                    [0, 0.4, 0.770, 1.0],   
                    [0, 0.4, 0.770, 1.0],  
                ];
                document.getElementById("childBtn2").value = "CHILD";
            }

            main();
        }

        // Alpha SLIDER functions
        function changeS2value() {
            // pass slider value into global variable "transparencyValue" 
            transparencyValue = document.getElementById("s2Value").value / 10;
            // change "alphaValue" label/span
            document.getElementById("alphaValue").innerHTML = transparencyValue;
            // calling the colorGrand() function
            if (colorGrandBool == false) { colorGrandBool = true; }
            else { colorGrandBool = false; }
            colorGrand();
        }

    </script>
</head>

<body style="font-family: Arial, Helvetica, sans-serif; text-align: center;">
    <div style="padding: 10px 0px 10px 0px;">
        <div style="padding-bottom:7px; font-size:0.8em;">Drag mouse inside canvas to rotate PARENT on x-axis and y-axis</div>
        <input type="button" style="margin:1px; width:23%;" id="resetBtn" value="Reset rotation" onclick="resetRotation()">
    </div>
    <canvas id="glCanvas" width="640" height="480"></canvas>
    <br><br>
    <table width="640" cellpadding="0" cellspacing="5" border="0" align="center">
        <tr>
            <td align="center" style="font-size:0.8em;">PARENT movement (x-axis): <span id="pMoveX">0</span>
                <input oninput="changeP1value()" id="p1Value" type="range" min="-10" max="10" value="0" style="width: 100%"></td>
            <td rowspan="3" width="5%" style="border-right: 1px dashed #999;"></td>
            <td rowspan="3" width="3%"></td>
            <td align="center" style="font-size:0.8em;">CAMERA movement (x-axis): <span id="cMoveX">0</span>
                <input oninput="changeC1value()" id="c1Value" type="range" min="-10" max="10" value="0" style="width: 100%"></td>
        </tr>
        <tr>
            <td align="center" style="font-size:0.8em;">PARENT movement (y-axis): <span id="pMoveY">0</span>
                <input oninput="changeP2value()" id="p2Value" type="range" min="-10" max="10" value="0" style="width: 100%"></td>
            <td align="center" style="font-size:0.8em;">CAMERA movement (y-axis): <span id="cMoveY">1</span>
                <input oninput="changeC2value()" id="c2Value" type="range" min="-10" max="10" value="1" style="width: 100%"></td>
        </tr>
        <tr>
            <td align="center" style="font-size:0.8em;">PARENT movement (z-axis): <span id="pMoveZ">0</span>
                <input oninput="changeP3value()" id="p3Value" type="range" min="-10" max="10" value="0" style="width: 100%"></td>
            <td align="center" style="font-size:0.8em;">CAMERA movement (z-axis): <span id="cMoveZ">10</span>
                <input oninput="changeC3value()" id="c3Value" type="range" min="-10" max="10" value="10" style="width: 100%"></td>
        </tr>
    </table>
    <table width="640" cellpadding="0" cellspacing="5" border="0" align="center">
        <tr><td colspan="2"><hr></td></tr>
        <tr>
            <td width="40%" align="right">Perform transformation: </td>
            <td>
                <input type="button" style="margin:5px; width:45%;" id="childBtn" value="CHILD" onclick="transformChild()">
                <input type="button" style="margin:5px; width:45%;" id="grandBtn" value="GRANDCHILD" onclick="transformGrand()">
            </td>
        </tr>
        <tr>
            <td align="right" style="font-size:0.8em;">GRANDCHILD transformation speed: <span id="speedValue">1</span></td>
            <td><input oninput="changeS1value()" id="s1Value" type="range" min="1" max="10" value="0" style="width: 100%"></td>
        </tr>
        <tr><td colspan="2"><hr></td></tr>
        <tr>
            <td align="right">Change color: </td>
            <td>
                <input type="button" style="margin:5px; width:45%;" id="childBtn2" value="CHILD" onclick="colorChild()">
                <input type="button" style="margin:5px; width:45%;" id="grandBtn2" value="GRANDCHILD" onclick="colorGrand()">
            </td>
        </tr>
        <tr>
            <td align="right" style="font-size:0.8em;">GRANDCHILD alpha value: <span id="alphaValue">1</span></td>
            <td><input oninput="changeS2value()" id="s2Value" type="range" min="0" max="10" value="10" style="width: 100%"></td>
        </tr>
    </table>
</body>